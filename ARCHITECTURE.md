# Architecture & Design

**blender-ai-mcp** enables precise, deterministic control of Blender by AI (LLM/MCP).
Instead of executing raw Python code generated by models (which is error-prone), the project provides a stable toolset via the Model Context Protocol.

---

## üß± System Architecture

```
+------------------+        +---------------------+         +---------------------+
|     AI Model     | -----> |     MCP Server      | <-----> |   Blender Add-on    |
| (ChatGPT / LLM)  |        | (Python Fast-MCP)   |   RPC   | (bpy + RPC wrapper) |
+------------------+        +---------------------+         +---------------------+

                            Clean Architecture Layers
                -------------------------------------------
                Domain | Application | Adapters | Infra
```

### 1. MCP Server (Client Side)
A Python application that exposes tools to the AI model and acts as a client for the Blender Addon.
- **Domain**: Defines interfaces (`IModelingTool`) and models (`RpcRequest`).
- **Application**: Implements tool logic (`ModelingToolHandler`) using dependency injection.
- **Adapters**: Implements `RpcClient` (sockets) and `FastMCP` endpoints.
- **Infrastructure**: DI Container and Configuration.

### 2. Blender Addon (Server Side)
A plugin running inside Blender's Python environment (`bpy`).
- **Infrastructure**: Threaded TCP Server (`rpc_server.py`) that safely schedules tasks on the main thread.
- **Application**: Handlers (`SceneHandler`, `ModelingHandler`) that execute actual `bpy` operations.

---

## üîÑ Data Flow

```
AI -> MCP Server (Adapter) -> Application Handler -> RPC Client (Adapter)
      -> JSON-RPC over TCP ->
Blender Addon (Infrastructure) -> Application Handler -> bpy API -> Result
```

**Example Request:**
```json
{
  "tool": "create_primitive",
  "args": { "primitive_type": "Cube", "size": 2.0 }
}
```

---

## üß† "Stable Blender Tools" Design Philosophy

### ‚ùå Bad Practice: 1 Tool = 1 Blender API Function
Blender has over 1200 operators. Exposing them directly confuses the AI and leads to context errors.

### ‚úî Good Practice: 1 Tool = 1 Logical Modeling Task
We group operations into high-level, robust tools.

**Examples:**
- **Bad:** `mesh.primitive_cube_add`, `transform.translate`
- **Good:** `create_primitive(type="Cube")`, `transform_object(name="Cube")`

**Every Tool Must:**
- Manage mode (Object/Edit) automatically.
- Manage selection state.
- Validate arguments.
- Return descriptive JSON/Text results.
- Handle Blender context exceptions gracefully.

---

## üß© Tool Categories

### 1) Scene Tools
- `list_objects`: Get scene content.
- `delete_object`: Remove specific items.
- `clean_scene`: Factory reset the scene.

### 2) Modeling Tools
- `create_primitive`: Cube, Sphere, Cylinder, etc.
- `transform_object`: Move, Rotate, Scale.
- `add_modifier`: Subsurf, Bevel, Boolean.

---

## üèó Best Practices & Standards

- **Clean Architecture**: Strict separation of concerns. Domain never depends on Frameworks.
- **Dependency Injection**: All dependencies are injected via providers (`di.py`).
- **Thread Safety**: The Addon uses `bpy.app.timers` to ensure thread safety when handling RPC requests.
- **No "Raw Code"**: The AI calls tools, it never executes arbitrary Python scripts.

---

## üì° RPC Protocol

**Request:**
```json
{
  "request_id": "uuid-v4",
  "cmd": "modeling.create_primitive",
  "args": { "primitive_type": "Cube" }
}
```

**Response:**
```json
{
  "request_id": "uuid-v4",
  "status": "ok",
  "result": { "name": "Cube", "type": "MESH" }
}
```
